# Handcrafting Finite State Machines

## Introduction

This document is my attempt to define a repeatable recipe for creating Finite State Machines (FSMs).
Although I'm familiar with the concepts behind FSMs, I've not written enough of them to call
myself skilled at developing them.  I'm sure that the first draft of this recipe will have
a lot of shortcomings, and I hope to discover those shortcomings through the process of
applying this recipe in different areas.

## Notes

* This recipe will focus on the Java programming language.
* At a certain level of complexity (e.g. a large number of states, a large number of events, or both),
handcrafting an FSM may become too onerous and other tools for generating FSMs become much more attractive.
* This document is limited to FSMs that are accessed from only a single thread.

## Goals

I would like this recipe to:

* be simple to follow,
* be useful for creating loosely coupled, fairly scalable FSMs,
* be useful for creating composable FSMs,
* create beautiful and simple designs that are easily understood,
* suggest ways of testing the FSM

## The Example

If you've read ["Designing Object Oriented C++ Applications Using The Booch Method"](http://www.amazon.com/dp/0132038374)
by Robert C. Martin, you may recall the case study of the Mark IV Coffee Maker.  It's a fairly simple FSM which makes
it a great example for a first application of this recipe.  I won't go into all of the details  (they are available in
the book and online) but the Mark IV Coffee Maker is your typical Coffee Maker with:

* a "Brew" button that initiates the brew cycle if it's safe to do so,
* a Boiler that heats the water,
* a WaterLevelSensor that detects whether there is water in the Boiler,
* a PotSensor that detects whether or not the CoffeePot is on the PotWarmer and, if it is, whether or not it is empty,
* A PotWarmer that keeps the freshly brewed coffee nice and hot,
* and a Coffee Pot.

The Mark IV, unlike the Mark III, has a feature where the user can "sneak" a cup during the brew cycle, which temporarily
causes the brewing cycle to pause.  Once the CoffeePot is returned to the PotWarmer, the brewing cycle resumes.

Note: I may not stay completely true to the book's case study.

Note: If I'm writing about something that shows up in the design as an object, I'll refer to it by the name of its class.
For example, if I'm writing about a coffee pot, I'll write CoffeePot because there will be a CoffeePot in the design.

## Finite State Machines

An FSM contains three kinds of entities (among others): States, Sensors, and Actuators.

## Sensors

A Sensor is a component (hardware, software, or a combination of both) that receives precepts from outside of the FSM.  In the Coffee Maker
example, a sensor might be a PotSensor that detects whether or not a CoffeePot is present.  Sensors have two main
capabilities, reporting their state, and notifying interested components when their state changes.

Sensors have two responsibilities, 1) to initiate state transitions within the FSM by reporting precepts sensed by the
Sensors to the FSM and 2) providing query operations that states (represented by classes) can call to determine which
state to transition to.  I'll provide more details on that later.

Sensors are dynamic entities that influence state transitions but do not define the
current state of the FSM.  To that end, I largely ignore Sensors and their state in the construction of State Transition
Tables.

## Actuators

An Actuator is a component (hardware, software, or a combination of both) that can be commanded by the FSM to take some
action that interacts with something outside the FSM.  This could be a motor, a light, a camera, or, in the case of the
CoffeeMaker, a PotWarmer used to keep freshly brewed coffee nice and hot.

Actuators and Sensors are the only way that the FSM has of communicating with the world outside of the FSM.

Actuators don't have to be related to hardware.  You could have an Actuator that emailed a user when the CoffeePot was
done brewing.

## Responsibilities of the FSM

The main responsibility of the FSM is keeping all Actuators in the correct state under all possible state transitions
and potential failures.

## Events Generated By Sensors

Let's begin creating our CoffeePot FSM by listing the Sensors and the states they can be in.  These states and the
implied state transitions will provide a good initial list of events our FSM must handle.

* BrewButton: Pressed | NotPressed
* PotSensor: NoPot | EmptyPot | NonEmptyPot
* WaterLevelSensor: Empty | NotEmpty

## Initial State Space Construction

Next we list all of the Actuators and their potential states.  In the Coffee Maker we have only two actuators:

* Boiler: On | Off
* Pot Warmer: On | Off

Using the [Rule of Product](http://en.wikipedia.org/wiki/Rule_of_product) we can see that there are four (2 x 2)
combinations of Actuator states:

* Boiler Off, Pot Warmer On
* Boiler Off, Pot Warmer Off
* Boiler On,  Pot Warmer On
* Boiler On,  Pot Warmer Off

## State Space Reduction

The next step is to eliminate any illegal combinations of actuator states.  In my take of the Mark IV Coffee Maker,
it does not make sense to warm the CoffeePot while the coffee is brewing.  This is because while the coffee is brewing,
the brewed coffee in the CoffeePot does not have a chance to cool down to the point where it needs to be heated.

That leaves us with three combinations of actuator states:

* Boiler Off, Pot Warmer Off
* Boiler On,  Pot Warmer Off
* Boiler Off, Pot Warmer On

## Naming States

Next we name the the combinations of actuator states, keeping in mind that a particular combination of actuator states
(e.g Boiler Off and Pot Warmer Off) may actually appear in multiple states of your FSM.  In other words given the state
of the actuators, one cannot say for certain which of the FSM's states the FSM is in.  That uncertainty will be shown
more clearly soon.

Let's take a first cut at naming states:

* Boiler Off, Pot Warmer Off => Initial
* Boiler On,  Pot Warmer Off => Brewing
* Boiler Off, Pot Warmer On  => Warming

## Discovering Additional States

For each of the combinations of actuator states we listed above, we consider how the FSM should handle each state
transition we listed above.  In the process we may discover new states.

For example, if the FSM is in the BrewingState and the FSM is told by the PotSensor that the CoffeePot has been removed, we
know that 1) there is no CoffeePot to heat so the FSM should turn off the PotWarmer and 2) continuing to boil the water when
it has nowhere to go is not a good idea so we need to turn off the Boiler.  That leaves us with the same configuration of
actuator states as the Initial state.  Should we just transition to the Initial state in this case, or do we need a new
state?  Remembering the requirement that if a user removes the CoffeePot while brewing and then replaces the pot, we
should resume brewing, this suggests that we should not return to the Initial state.  We need a state, that handles the
CoffeePot being replaced by turning the Boiler back on.  Let's call this newly discovered state the BrewingInterrupted state.
Here is our updated list of states.

* Boiler On, Pot Warmer Off  => Brewing
* Boiler Off, Pot Warmer On  => Warming
* Boiler Off, Pot Warmer Off => Initial | BrewingInterrupted

As another example of state discovery, let's consider what happens when the CoffeeMaker has finished the brew cycle and is
now warming a CoffeePot.  If, in this Warming state, the user removes the CoffeePot, we should turn the PotWarmer off because
there is nothing to warm.  That would leave us with the Boiler off and the Pot Warmer off, the same configuration of actuator
states as the Initial and BrewingInterrupted states.  Do we need a new state?  Yes, we need a state that, when the CoffeePot
is replaced and it is not empty, we turn on the PotWarmer to keep it warm.  Let's call this state WarmingInterrupted.
That leaves us with the following states:

* Boiler On, Pot Warmer Off => Brewing
* Boiler Off, Pot Warmer On => Warming
* Boiler Off, Pot Warmer Off => Initial | BrewingInterrupted | WarmingInterrupted

Let's continue the state discovery.  If we are in the WarmingInterrupted state and we put an empty CoffeePot back into the Coffee Maker,
then we should leave both the Boiler and the PotWarmer off.  In this case, we don't need a new state;  we have returned to the
Initial state.  State discovery can continue for a good deal longer for more complex FSMs.

At this point we have all the states we need to handle the basic use cases:

* Initial
* Brewing
* Warming
* BrewingInterrupted
* WarmingInterrupted

## Guard Conditions

What happens when we're in the Initial state (with the Boiler off and the PotWarmer off) and we press the Brew button?
We don't want to start brewing if there is no water in the Boiler.  Should we create another state called ReadyToBrew
that we only enter when the Boiler has water in it?  We could, but in this case I'll use a Guard Condition in the
Initial state to determine which state should be transitioned to (if any) when the Brew button is pressed in the Initial
state.

If we introduce the ReadyToBrew state, then when we're in the WarmingInterrupted state and we replace the CoffeePot, we
need to check the water level in the Boiler to see if we should go to the Initial state (if there's no water) or go to
the ReadyToBrew state (if there is water).  Either way we need to check some sensors, but the first approach
does not require an additional state.

You'll find that when you're handcrafting an FSM, there is no one best way and you'll be balancing trade-offs throughout
the process.

The following pseudo-code shows how the Guard Condition can be used in the Initial state:

        onBrewButtonButtonStateChanged(newState) {
            if (newState == Pressed) {
                    if (boiler has water in it)
                        transition to Brew State
                    else
                        stay in Initial State
            }
        }

## Testing FSMs

There are two main things to check when testing an FSM:

* Interaction Verification - Given a particular state, and a sequence of Sensor state changes, the FSM should interact
with the Actuators in a specified way (e.g. turning on a Boiler, turning off the PotWarmer).  These interactions can be
verified using [Test Spies](http://en.wikipedia.org/wiki/Test_double) or Mock Objects.

* State Verification - Given a particular state, and a sequence of Sensor events, is the FSM in the correct
state?

## Implementation of the FSM

### Actuators

To minimize coupling between the FSM and concrete Actuator classes, Actuators are implemented as Java interfaces.
The simplest Actuators have only command methods that instruct the Actuator to perform some action or assume some
state (e.g. turnOn, turnOff).  More complex Actuators may have methods for querying state or methods that throw
exceptions if some command could not be carried out by the actuator.

Here is an example actuator interface:

        public interface Boiler {
            void turnOff();
            void turnOn();
        }

When testing the FSM, you can create a Boiler spy that remembers the last state of the boiler and allows your
unit test test to interrogate that state.  This in an example of Interaction Verification.  Here is one
possible implementation of the BoilerSpy.

        class BoilerSpy implements Boiler {
            private boolean on = false;
            public void turnOn()  { on = true; }
            public void turnOff() { on = false; }
            public boolean isOn() { return on; }
        }

### Sensors

For every Sensor that the FSM receives precepts from, there will be a Sensor class.  This Sensor class does not really
do any sensing of it's own.  It is told by other software components outside the FSM when precepts are detected.  This
approach is taken to decouple the actual sensing, which may depend on hardware devices from the FSM and related classes.
The software components outside the FSM (be they hardware or software) that actually do the sensing will have references
to instances of the Sensor class and will call methods on the Sensor whenever those components change state.

For example in the Coffee Maker case study, there would be a hardware WaterLevelSensor that could generate interrupts
that software could trap and then call a method on the interrupt handler's WaterLevelSensor instance.

The Sensor class should declare a nested interface named Listener that has methods used for communicating sensed changes to
interested objects.  I prefer to prefix the methods in the Sensor class with detect because callers are literally
telling the Sensor instance what to detect.  For example, here's what we'd write for the WaterLevelSensor:

        class WaterLevelSensor {
            // some code omitted...
            enum State { Empty, NotEmpty }
            public interface Listener {
                void onWaterLevelStateChange(final State newState);
            }
            public void addListener(final Listener listener) {
                // adds listener to a collection of listeners
            }
            public void detectStateChange(final State newState) {
                // for each registered listener calls onWaterLevelStateChange() with the new state
            }
            public State getState() { /* return current state */ }
        }

The Sensor class has the following responsibilities:

* declare a Listener interface that other components can implement so that they can be told when the Sensor
changes state,
* maintain a list of listeners,
* declare one or more "detect" methods that results in letting listeners know about a change in state or some other event,
* declare one method that retrieves the current state of the Sensor.

#### Testing Sensors

Testing Sensors is straightforward.  You create a Sensor instance, create a Mock Listener object and register it with the
Sensor instance.  Then you set up an expectation on the Mock object to have a specific method called with a particular
parameter.  Then you call the "detect" method that should call the expected method on the mock.  If the expectation is
met, the test passes.

### The FSM Class

At this point we have defined the states that our FSM can be in, the Sensors that trigger transitions between those
states and the Actuators that the FSM controls in response to state transitions.  We still need to implement the FSM
class, and all of its states, and then write unit tests for our FSM.

Let's start with the FSM.  The code will start simple and I'll progressively add more and more to it while describing
what I'm doing:

        public class CoffeeMaker {
        }

Remember that one of the ways we want to test our FSM is by putting it into a state and then causing it to transition
to another state and then verifying that it's in that state.  To support that, we'll create a public enumeration that
lists all of the CoffeeMaker's possible states and provide a method that will allow unit tests to query the FSM's state:

        public class CoffeeMaker {
            enum State { Initial, Brewing, Warming, BrewingInterrupted, WarmingInterrupted }
            State getState() { /* return current state */ }
        }

Our FSM has two Sensors and we want our FSM to be told when those Sensors sense new things.  Here is where the Listener
interfaces come in.  Our FSM will implement the Listener interfaces of our Sensors like this:

        public class CoffeeMaker implements WaterLevelSensor.Listener,
            PotSensor.Listener, BrewButton.Listener {

            enum State { Initial, Brewing, Warming, BrewingInterrupted, WarmingInterrupted }
            State getState() { /* return current state */ }

            @Override void onBrewButtonStateChanged(BrewButton.State newState) { /* implementation omitted */ }
            @Override void onWaterLevelChanged(WaterLevelSensor.State newState) { /* implementation omitted*/ }
            @Override void onPotStateChanged(PotSensor.State newState) { /* implementation omitted */ }
        }

Next we'll define the abstract base class that is the superclass of all of the states our FSM can be in.  It will have
one method for every method of every Listener that the FSM implements.  I'll call this class AbstractState.  I like the
idea that a state should be able to choose which state it should transition to in response to an event so every event
handling method in AbstractState will return an instance of AbstractState that represents the new state of the FSM
in response to the event.  One nice property of the AbstractState class is that in all of the event handlers it defines,
it never transitions to a new state; it just returns itself.  This is useful for derived states that only care about a
subset of the events a state can respond to. Here is the code:

        public class CoffeeMaker implements WaterLevelSensor.Listener,
            PotSensor.Listener, BrewButton.Listener {

            enum State { Initial, Brewing, Warming, BrewingInterrupted, WarmingInterrupted }
            State getState() { /* return current state */ }

            static abstract class AbstractState {
                AbstractState onBrewButtonStateChanged(BrewButton.State newState) { return this; }
                AbstractState onWaterLevelChanged(WaterLevelSensor.State newState) { return this; }
                AbstractState onPotStateChanged(PotSensor.State newState) { return this; }
            }

            @Override void onBrewButtonStateChanged(BrewButton.State newState) { /* implementation */ }
            @Override void onWaterLevelChanged(WaterLevelSensor.State newState) { /* implementation */ }
            @Override void onPotStateChanged(PotSensor.State newState) { /* implementation */ }
        }

We need to keep track of our FSM's current state so let's add an instance variable of type AbstractState:

        public class CoffeeMaker implements WaterLevelSensor.Listener,
            PotSensor.Listener, BrewButton.Listener {

            private AbstractState abstractState = /* instance of InitialState class which is not yet defined */

            enum State { Initial, Brewing, Warming, BrewingInterrupted, WarmingInterrupted }
            State getState() { /* return current state */ }

            static abstract class AbstractState {
                public AbstractState onBrewButtonStateChanged(BrewButton.State newState) { return this; }
                public AbstractState onWaterLevelChanged(WaterLevelSensor.State newState) { return this; }
                public AbstractState onPotStateChanged(PotSensor.State newState) { return this; }
            }

            @Override void onBrewButtonStateChanged(BrewButton.State newState) { /* implementation */ }
            @Override void onWaterLevelChanged(WaterLevelSensor.State newState) { /* implementation */ }
            @Override void onPotStateChanged(PotSensor.State newState) { /* implementation */ }
        }

To help implement the FSM's getState method we add this method to AbstractState:

        public State getState();

Then we can define the FSM's getState method as:

        State getState() { return abstractState.getState(); }

That leaves us with:

        public class CoffeeMaker implements WaterLevelSensor.Listener,
            PotSensor.Listener, BrewButton.Listener {

            private AbstractState abstractState = /* instance of InitialState class which is not yet defined */

            enum State { Initial, Brewing, Warming, BrewingInterrupted, WarmingInterrupted }
            State getState() { return abstractState.getState(); }

            static abstract class AbstractState {
                public State getState();
                public AbstractState onBrewButtonStateChanged(BrewButton.State newState) { return this; }
                public AbstractState onWaterLevelChanged(WaterLevelSensor.State newState) { return this; }
                public AbstractState onPotStateChanged(PotSensor.State newState) { return this; }
            }

            @Override void onBrewButtonStateChanged(BrewButton.State newState) { /* implementation */ }
            @Override void onWaterLevelChanged(WaterLevelSensor.State newState) { /* implementation */ }
            @Override void onPotStateChanged(PotSensor.State newState) { /* implementation */ }
        }

So far we have not shown how the actual state classes (derived from AbstractState) will interact with Sensors and
Actuators.  It's certain that the FSM will have references to the Actuators and Sensors so that it can control the
Actuators and query the state of the Sensors.  One goal I have is for the FSM to encapsulate the Actuators and Sensors
so that there is almost no chance that another component could access an Actuator and tell it to do something without
the FSM's knowledge.  I also want to keep the signatures of the state classes' methods simple so passing all of the
Actuators and Sensors as individual parameters is not an option.  To meet these goals, I declare a nested class in the
FSM called Components.  It owns all of the Actuators and Sensors.  Here is the Components nested class shown by itself:

        static class Components {

            // Actuators
            Boiler boiler;
            PotWarmer potWarmer;

            // Sensors
            BrewButton brewButton;
            WaterLevelSensor waterLevelSensor;
            PotSensor potSensor;

            Components(
                   final Boiler boiler,
                   final PotWarmer potWarmer,
                   final WaterLevelSensor waterLevelSensor,
                   final PotSensor potSensor,
                   final BrewButtonSensor brewButton
            ) {
                this.boiler = boiler;
                this.potWarmer = potWarmer;

                this.waterLevelSensor = waterLevelSensor;
                this.potSensor = potSensor;
                this.brewButton = brewButton;
            }

            public Boiler getBoiler() { return boiler; }
            public PotWarmer getPotWarmer() { return potWarmer; }
            public WaterLevelSensor getWaterLevelSensor() { return waterLevelSensor; }
            public PotSensor getPotSensor() { return potSensor; }
            public BrewButtonSensor getBrewButton() { return brewButton; }
        }

The CoffeePot FSM will have an instance variable of type Components that is initialized in the constructor of the FSM.
Incidentally, to maximize testability of the FSM, all Actuators and Sensors are passed to the FSM constructor which
looks like this:

        public CoffeeMaker(
                final Boiler boiler,
                final PotWarmer potWarmer,
                final WaterLevelSensor waterLevelSensor,
                final PotSensor potSensor,
                final BrewButtonSensor brewButton
        ) {
            components = new Components(boiler, potWarmer, waterLevelSensor, potSensor, brewButton);
        }

Lets add the code to wire up the Sensors and our FSM:

        public CoffeeMaker(
                final Boiler boiler,
                final PotWarmer potWarmer,
                final WaterLevelSensor waterLevelSensor,
                final PotSensor potSensor,
                final BrewButtonSensor brewButton
        ) {
            components = new Components(boiler, potWarmer, waterLevelSensor, potSensor, brewButton);

            // listen for state changes
            components.getWaterLevelSensor().addListener(this);
            components.getPotSensor().addListener(this);
            components.getBrewButton().addListener(this);
        }

Let's change the signature of the AbstractState event handlers to take an instance of the Components class so that
the state classes' event handlers can interact with the Actuators and Sensor of the FSM:


        static abstract class AbstractState {
            State getState();
            AbstractState onBrewButtonStateChanged(BrewButton.State newState, Components components) { return this; }
            AbstractState onWaterLevelChanged(WaterLevelSensor.State newState, Components components) { return this; }
            AbstractState onPotStateChanged(PotSensor.State newState, Components components) { return this; }
        }

Now that we've added our FSM as a listener to all of our Sensor objects, our FSM will get notified whenever a Sensor
emits an event (e.g. state change).  Here are the FSM methods we've overridden from each of the Listener interfaces our
FSM has implemented:

        @Override
        public void onBrewButtonStatusChanged(BrewButtonSensor.State newState) {
            state = state.onBrewButtonStateChanged(components, newState);
        }

        @Override
        public void onPotStatusChanged(PotSensor.State newState) {
            state = state.onPotStateChanged(components, newState);
        }

        @Override
        public void onWaterLevelChanged(WaterLevelSensor.State newState) {
            state = state.onWaterLevelStateChanged(components, newState);
        }

Notice that we assign the result of the state's event handler to the FSM's state instance variable.  This is how
the FSM transitions from one state to another (or doesn't if the state's event handler just returns this).  Notice also
how each event handler is passed the FSM's components instance variable.

Now we can implement one of the FSM's state classes, InitialState:

        class InitialState extends CoffeeMaker.AbstractState {

            @Override
            public CoffeeMaker.State getState() {
                return CoffeeMaker.State.Initial;
            }

            @Override
            public CoffeeMaker.AbstractState onBrewButtonStateChanged(
                    final BrewButtonSensor.State newState,
                    final CoffeeMaker.Components components) {

                switch (newState) {
                    case Pressed:
                        if (components.getWaterLevelSensor().getWaterLevel() == WaterLevelSensor.State.NotEmpty &&
                                components.getPotSensor().getState() == PotSensor.State.Empty) {
                            components.getBoiler().turnOn();
                            return new BrewingState();
                        }
                        break;
                }

                return this;
            }
        }

This state is only interested in the state changes of the BrewButton so it only implements the event handler related to
the BrewButton.  If newState is Pressed and the WaterLevelSensor reports a non-empty Boiler and the PotSensor
detects an empty pot, then it turns on the Boiler and returns a new BrewingState() object.  Otherwise it stays in the
initial state.

All of the other states are defined in roughly the same way.

## Testing the FSM

Assuming you've defined a BoilerSpy and a PotWarmerSpy class, you can run the following JUnit Unit Test:

        public class CoffeeMakerTest {

            private CoffeeMaker coffeeMaker;

            private BoilerSpy boilerSpy;
            private PotWarmerSpy potWarmerSpy;

            private PotSensor potSensor;
            private WaterLevelSensor waterLevelSensor;
            private BrewButtonSensor brewButtonSensor;

            @Before
            public void setUp() {
                boilerSpy = new BoilerSpy();
                potWarmerSpy = new PotWarmerSpy();

                potSensor = new PotSensor();
                waterLevelSensor = new WaterLevelSensor();
                brewButtonSensor = new BrewButtonSensor();

                coffeeMaker = new CoffeeMaker(boilerSpy, potWarmerSpy,
                    waterLevelSensor, potSensor, brewButtonSensor);
            }

            @Test
            public void wontBrewWithoutWater() {
                potSensor.detect(PotSensor.State.Empty);
                brewButtonSensor.detect(BrewButtonSensor.State.Pressed);

                assertFalse(boilerSpy.isOn());
            }
        }

The Boiler remains off after the BrewButton is pressed because the InitialState class uses Guard Conditions to
prevent starting a Brew cycle when the Boiler is empty.

You could also add this test to do State Verification:

            @Test
            public void staysInInitialStateWithoutWater() {
                potSensor.detect(PotSensor.State.Empty);
                brewButtonSensor.detect(BrewButtonSensor.State.Pressed);

                assertEquals(CoffeeMaker.State.Initial, coffeeMaker.getState());
            }

## Composing FSMs

You may have noticed that the the Sensors and the FSM have one property in common: they can both be queried for their
state.  If the FSM defined it's own Listener interface, allowed Listeners to register with the FSM, and notified those
listeners when it changed states, then you could compose FSMs into larger FSMs (e.g. a CoffeeMaker that requires payment).

## Handling Failure

Failures can originate from at least two places: 1) A Sensor can be damaged such that it can no longer accurately sense
precepts and 2) An Actuator may become damaged and no longer be able to effect change outside of the FSM.

### Sensors

In an ideal world, every Sensor that can fail would have a "Failed" state as part of their state enum.  Then the FSM
could listen for transitions to the Failed state and handle the failure appropriately.  It could be that the FSM should
define its one Failed state that it could transition to if a Sensor failed.  It could be that the FSM switches over to
a fallback strategy if a Sensor fails.

### Actuators

A failed Actuator should throw exceptions if it cannot carry out a command issued by an FSM state.  When an exception is
caught by the FSM, it should probably transition to a Failed state unless there is an adequate fallback strategy.

## Code

This repository includes the code for the Mark IV CoffeeMaker as designed using this recipe.  There are probably some
subtle differences between the code in this document and the code in the repository.